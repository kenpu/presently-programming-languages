{
    "type": "article",
    "source": "Functions & Higher Order Functions",
    "children": [
        {
            "type": "page",
            "source": "Defining functions",
            "children": [
                {
                    "type": "section",
                    "source": "Simple definition",
                    "children": [
                        {
                            "type": "box",
                            "layout": "horizontal",
                            "source": "",
                            "children": [
                                {
                                    "type": "markdown",
                                    "source": "c: center\n............\n- Expressions that evaluate to functions\n> - Specification of the input parameters\n> - Specification of the return type\n> - Specification of the body of the function\n>  > <note/> Can make use of the function to the declared.",
                                    "uuid": "fe65134a-cacd-4b07-859a-36922c91cf16",
                                    "version": 0
                                }
                            ],
                            "uuid": "27683e94-68ed-462e-8027-5829d7ac3307",
                            "version": 0
                        },
                        {
                            "type": "box",
                            "layout": "horizontal",
                            "source": "",
                            "children": [
                                {
                                    "type": "markdown",
                                    "source": "Scala.\n\n1. Declaration of a symbol\n2. Binding it to a function expression",
                                    "uuid": "cfb6018a-d05a-4fbf-a001-ca3330c3cecd",
                                    "version": 0
                                },
                                {
                                    "type": "code",
                                    "source": "lang: scala\n...............\ndef factorial(n:Int):Int = {\n  if(n <= 1)\n    1\n  else\n    factorial(n-1) * n\n}",
                                    "uuid": "996990c9-0ee5-40ac-a7ba-1fb185c0f943",
                                    "version": 0
                                }
                            ],
                            "uuid": "92cbb231-3e1d-4dae-bd95-eda8d1ee1d2d",
                            "version": 0
                        },
                        {
                            "type": "box",
                            "layout": "horizontal",
                            "source": "",
                            "children": [
                                {
                                    "type": "markdown",
                                    "source": "Scala.\n\nAnother way of defining a function with less syntactic sugar.\n\n1. We are using an expression that evaluates to a function.",
                                    "uuid": "74e97929-7288-4ad0-b702-24f7288b4af6",
                                    "version": 0
                                },
                                {
                                    "type": "code",
                                    "source": "lang: scala\n...............\nval factorial : Int => Int = {\n  i => {\n    if(i <= 2) 1 else factorial(i-1) * i\n  }\n}",
                                    "uuid": "53dd4cd2-4e0b-45a9-bd9e-8383e72d9552",
                                    "version": 0
                                }
                            ],
                            "uuid": "0c2c95ee-178e-48bd-b5a5-0626c9c82b58",
                            "version": 0
                        }
                    ],
                    "uuid": "b1cb4f85-110e-4cda-b6a9-60cc0b8a4717",
                    "version": 0
                },
                {
                    "type": "section",
                    "source": "..............\nCurrying: function as output",
                    "children": [
                        {
                            "type": "box",
                            "layout": "horizontal",
                            "source": "w: 1 2",
                            "children": [
                                {
                                    "type": "markdown",
                                    "source": "- Functions as values is _powerful_.\n- Functions can return functions.",
                                    "uuid": "2dc1c710-2cfe-4f16-983b-d1467f72210a",
                                    "version": 0
                                },
                                {
                                    "type": "markdown",
                                    "source": "> <note/>\n> _Currying:_\n> \n> We convert multi-argument function to a chain of single-argument functions. ",
                                    "uuid": "d46bb3f9-ffbf-4a08-a0a9-8282d8edfe2e",
                                    "version": 0
                                }
                            ],
                            "uuid": "3cd9c4dd-f680-4a35-b74a-474e27839565",
                            "version": 0
                        },
                        {
                            "type": "box",
                            "layout": "horizontal",
                            "source": "w: 1 2",
                            "children": [
                                {
                                    "type": "markdown",
                                    "source": "Scala\n\nA function with three arguments",
                                    "uuid": "fd0c25b0-8351-4e6a-a9db-e7251a9af40a",
                                    "version": 0
                                },
                                {
                                    "type": "code",
                                    "source": "lang: scala\n.......................\ndef substring(s:String, start:Int, end:Int) {\n\ts.substring(start, end)\n}",
                                    "uuid": "92dfc866-401e-4d68-925c-c2b3b57395b1",
                                    "version": 0
                                }
                            ],
                            "uuid": "2686e552-1a7d-4a57-b5d0-c82c20bb5a92",
                            "version": 0
                        },
                        {
                            "type": "box",
                            "layout": "horizontal",
                            "source": "w: 1 2",
                            "children": [
                                {
                                    "type": "markdown",
                                    "source": "Scala\n\nA function with one argument, but it returns a function which takes another argument.",
                                    "uuid": "0a67fead-e463-4127-8c21-6f88a38f2e85",
                                    "version": 0
                                },
                                {
                                    "type": "code",
                                    "source": "lang: scala\n.......................\nval substring : String => (Int => (Int => String)) = {\n  s => {\n    start => {\n      end => s.substring(start, end)\n    }\n  }\n}",
                                    "uuid": "a5444882-7a02-440a-8360-cc5c3525db6c",
                                    "version": 0
                                }
                            ],
                            "uuid": "2f898146-8e47-4d39-b631-f0cad3c74b2a",
                            "version": 0
                        },
                        {
                            "type": "box",
                            "layout": "horizontal",
                            "source": "w: 1 2",
                            "children": [
                                {
                                    "type": "markdown",
                                    "source": "Scala\n\nA function with one argument, but it returns a function which takes another argument.",
                                    "uuid": "62542688-39a5-4476-859b-40c3598283b7",
                                    "version": 0
                                },
                                {
                                    "type": "code",
                                    "source": "lang: scala\n.......................\nval substring : String => (Int => (Int => String)) = {\n  s => {\n    start => {\n      end => s.substring(start, end)\n    }\n  }\n}",
                                    "uuid": "089f94f3-a553-46bf-973d-658d650cb764",
                                    "version": 0
                                }
                            ],
                            "uuid": "82d049bc-95ee-4c4b-b4da-de12308d2f26",
                            "version": 0
                        },
                        {
                            "type": "box",
                            "layout": "horizontal",
                            "source": "w: 1 2",
                            "children": [
                                {
                                    "type": "markdown",
                                    "source": "Scala\n\nSome syntactic simplicification",
                                    "uuid": "d1165d5e-06ac-4cc0-b1f4-a5d56bf0378b",
                                    "version": 0
                                },
                                {
                                    "type": "code",
                                    "source": "lang: scala\n.......................\nval substring : String => Int => Int => String = {\n  s => start => end => s.substring(start, end)\n}",
                                    "uuid": "50713169-d00c-4f34-b9b2-9d3f0199d950",
                                    "version": 0
                                }
                            ],
                            "uuid": "8df2fad2-0a55-4c4a-aef8-3338060a0585",
                            "version": 0
                        },
                        {
                            "type": "box",
                            "layout": "horizontal",
                            "source": "",
                            "children": [
                                {
                                    "type": "markdown",
                                    "source": "Making sense of curried function:\n\n1. Given: `substring : String => Int => Int => String`\n2. Invocation:\n  ~~~\n  substring(\"hello\") : Int => Int => String\n  ~~~\n3. Chained invocation:\n  ~~~\n  substring(\"hello\")(1) : Int => String\n  ~~~\n  ~~~\n  substring(\"hello\")(1)(3) : String = \"hello\".substring(1,3) = \"el\"\n  ~~~\n",
                                    "uuid": "e483b0c4-c14a-4653-bb61-e489afc5f98c",
                                    "version": 0
                                }
                            ],
                            "uuid": "e8398399-daf5-4de4-b378-ca9622a6054e",
                            "version": 0
                        }
                    ],
                    "uuid": "aacf304e-ff9d-41be-a336-5fc0a1365c25",
                    "version": 0
                },
                {
                    "type": "section",
                    "source": "Closure",
                    "children": [
                        {
                            "type": "box",
                            "layout": "horizontal",
                            "source": "",
                            "children": [
                                {
                                    "type": "markdown",
                                    "source": "> <note/> *Closure* refers to the lexical scoping rule.  Namely, the context of the function body inherits the context of the scope in which it is *defined*.",
                                    "uuid": "52616766-bb99-4c07-9804-b3edccf4825b",
                                    "version": 0
                                }
                            ],
                            "uuid": "55fc921a-1ad8-4437-8e4b-f1e0b279fab8",
                            "version": 0
                        },
                        {
                            "type": "box",
                            "layout": "horizontal",
                            "source": "",
                            "children": [
                                {
                                    "type": "markdown",
                                    "source": "- Closure is considered a relatively modern feature.  It's not supported in C/C++, and partially supported before Java 8.\n- Closure is central to functional programs.\n- Closure is used in _currying_.",
                                    "uuid": "96ba21bc-2ec8-4420-bd7a-96886bbbef1c",
                                    "version": 0
                                }
                            ],
                            "uuid": "63550511-5876-4454-812d-ffb446cb2a54",
                            "version": 0
                        },
                        {
                            "type": "box",
                            "layout": "horizontal",
                            "source": "w: 1 0",
                            "children": [
                                {
                                    "type": "code",
                                    "source": "lang: scala\n.......................\nval substring : String => (Int => (Int => String)) = {\n  s => {\n    start => {\n      end => s.substring(start, end)\n    }\n  }\n} ",
                                    "uuid": "41482464-9f2a-49a7-94ba-69b1dd33098e",
                                    "version": 0
                                },
                                {
                                    "type": "markdown",
                                    "source": "css:\n  maxWidth: 300\n  color: blue\n..................\nNote the inner functions inherit the name bindings of the outer functions.",
                                    "uuid": "8a2248bf-4b6a-46b9-9793-a2e757290298",
                                    "version": 0
                                }
                            ],
                            "uuid": "25aa1cc6-7bb1-451a-be45-238f19007deb",
                            "version": 0
                        }
                    ],
                    "uuid": "b32ed32e-7473-4c20-b521-6d23b4d1b042",
                    "version": 0
                },
                {
                    "type": "section",
                    "source": "Closure as means of stateful programming",
                    "children": [
                        {
                            "type": "box",
                            "layout": "horizontal",
                            "source": "w: 2 3",
                            "children": [
                                {
                                    "type": "markdown",
                                    "source": "- In object-oriented programming, we have the ability of encapsulating the state as private members of an object.\n\n- The access to the states (read and write) is done by public methods the object.\n\n- This can be done by returning functions which share the same state variable through closure.",
                                    "uuid": "22d840ff-3676-4ec1-87fe-e772bbfbeac9",
                                    "version": 0
                                },
                                {
                                    "type": "code",
                                    "source": "lang: scala\n......................\ndef newPerson: Map[String]Any = {\n  var state = Map(\"name\" -> \"Jack\",\n                  \"age\" -> 42)\n  val name = () => {state(\"name\")}\n  val age = (n: Int) => { state(\"age\") = n }\n  (name, age)\n}",
                                    "uuid": "c2d23898-89ab-4ad1-8537-2d2419d2ca1c",
                                    "version": 0
                                }
                            ],
                            "uuid": "c97bedaa-c741-4ebf-95ca-8826e29efc06",
                            "version": 0
                        }
                    ],
                    "uuid": "878d45ef-a603-4a8f-8da5-b7435a318302",
                    "version": 0
                }
            ],
            "uuid": "3ba62a97-30cc-44d6-8b82-e3228d521fa3",
            "version": 0
        },
        {
            "type": "page",
            "source": "Side Effects",
            "children": [
                {
                    "type": "section",
                    "source": "Side Effects",
                    "children": [
                        {
                            "type": "box",
                            "layout": "horizontal",
                            "source": "w : 2 1",
                            "children": [
                                {
                                    "type": "markdown",
                                    "source": "> <note/> *Side-effects*\n> \n> We say that an expression has _side effects_ if any of the following occurs during the evaluation of the expression:\n> > 1. Change the symbol bindings in its context.\n> 1. Modify *any* data.\n> 2. Perform I/O.\n\nIf repeated evaluation of an expression results in different _state_, then the expression has side effects.",
                                    "uuid": "770fc463-6376-485f-8511-d0863ccfc80e",
                                    "version": 0
                                },
                                {
                                    "type": "markdown",
                                    "source": "c: banner\n.............\nSide effects are *bad*.",
                                    "uuid": "9ab9dafb-13d1-4718-8d94-af0397424d75",
                                    "version": 0
                                }
                            ],
                            "uuid": "19865784-bb3d-4ec5-9b3e-2dfe1b4e3852",
                            "version": 0
                        },
                        {
                            "type": "box",
                            "layout": "horizontal",
                            "source": "Examples:",
                            "children": [
                                {
                                    "type": "markdown",
                                    "source": "- Rebinding\n  > ~~~\n  var x = 10\n  x = 20\n  ~~~\n  \n- Modification of data\n  > ~~~\n  val x = Array(10, 20, 30)\n  x(0) = 100\n  ~~~\n  \n- I/O\n  > ~~~\n  import scala.io.Source\n  val content = Source.fromFile(\"data.txt\").mkString()\n  ~~~\n  > ~~~\n  println(\"Hello\")\n  ~~~",
                                    "uuid": "d5b5db67-e831-4cc4-8041-d5e114604880",
                                    "version": 0
                                }
                            ],
                            "uuid": "f018612f-6933-4968-b450-b0df4e0a4277",
                            "version": 0
                        }
                    ],
                    "uuid": "544d3d23-8b5c-4787-85bb-06906a143135",
                    "version": 0
                },
                {
                    "type": "section",
                    "source": "Functional programming",
                    "children": [
                        {
                            "type": "box",
                            "layout": "horizontal",
                            "source": "",
                            "children": [
                                {
                                    "type": "markdown",
                                    "source": "c: banner\n...................\nFunctional programming is the paradigm of programming that does not use side effects.  Ever.",
                                    "uuid": "6c07dd82-6b76-4286-8fb7-ec0b76081c43",
                                    "version": 0
                                }
                            ],
                            "uuid": "6639feab-8275-4546-81e3-b34736a8b174",
                            "version": 0
                        }
                    ],
                    "uuid": "6c9dffe0-0d37-4d3e-bbcf-ed28e8de1c19",
                    "version": 0
                }
            ],
            "uuid": "a77054fd-d651-4094-b3a7-69276c61777b",
            "version": 0
        },
        {
            "type": "page",
            "source": "Control structures & evaluation",
            "children": [
                {
                    "type": "section",
                    "source": "math:\n..........\nControl structure",
                    "children": [
                        {
                            "type": "box",
                            "layout": "horizontal",
                            "source": "",
                            "children": [
                                {
                                    "type": "markdown",
                                    "source": "A control structure is part of the programming language that affects the evaluation of an expression:\n\n  \n",
                                    "uuid": "176dd99e-fba9-49d5-a178-0e2c97ec9236",
                                    "version": 0
                                }
                            ],
                            "uuid": "39bff234-831a-42cb-9c4c-2e33f9c01878",
                            "version": 0
                        },
                        {
                            "type": "box",
                            "layout": "horizontal",
                            "source": "w: 2 3",
                            "children": [
                                {
                                    "type": "markdown",
                                    "source": "- Branching:\n  > *E* = If *cond* then *E1* else *E2*\n  >\n  > The overall expression *E* is evaluated to either *E1* or *E2* depending on the *cond*.\n  >\n  > **Important**:\n  >\n  > In the case of `if false then $E_1$ else $E_2$`, $E_1$ is **not** evaluated at all.  So, its side effects never take place.\n",
                                    "uuid": "aaeddd5e-41d1-4ea3-9f80-ace182388f0d",
                                    "version": 0
                                },
                                {
                                    "type": "markdown",
                                    "source": "c: banner\n...................\nCompare expressions with side effects and ones without.",
                                    "uuid": "46f21902-c409-4b0d-90ea-08e72062e057",
                                    "version": 0
                                }
                            ],
                            "uuid": "abc57937-9270-42c7-8a4f-6b4dadd5e9b3",
                            "version": 0
                        },
                        {
                            "type": "box",
                            "layout": "horizontal",
                            "source": "w: 2 3",
                            "children": [
                                {
                                    "type": "markdown",
                                    "source": "- Looping:\n  > *E* = while *cond* do *E1*\n  >\n  > The loop repeatedly evaluates *E1* until the condition is satisfied.\n  > The overall expression is the last time *E1* is evaluated.",
                                    "uuid": "d8da668b-4562-4959-98e2-7acaa54f1f41",
                                    "version": 0
                                },
                                {
                                    "type": "markdown",
                                    "source": "c: banner\n...................\nCompare expressions with side effects and ones without.",
                                    "uuid": "08ec10f9-5200-4c5c-a1bf-ae29cdbdf424",
                                    "version": 0
                                }
                            ],
                            "uuid": "beda21ff-9b9d-41d3-9a6d-1ed4794f7366",
                            "version": 0
                        },
                        {
                            "type": "box",
                            "layout": "horizontal",
                            "source": "",
                            "children": [
                                {
                                    "type": "markdown",
                                    "source": "Functional programming has no while loops.",
                                    "uuid": "bd4c9b6d-a83d-4f04-a367-d3328e7a2731",
                                    "version": 0
                                },
                                {
                                    "type": "markdown",
                                    "source": "c: banner\n...........\nWhy not?",
                                    "uuid": "ef13c6b1-8ba4-45f2-a2fa-2bd83f0ce550",
                                    "version": 0
                                }
                            ],
                            "uuid": "a988ed44-27f6-49ae-bf0a-c2bdc90722a5",
                            "version": 0
                        }
                    ],
                    "uuid": "1bc687a2-5931-4b5b-8d46-b8c72bb21384",
                    "version": 0
                },
                {
                    "type": "section",
                    "source": "Lazy evaluation of expressions",
                    "children": [
                        {
                            "type": "box",
                            "layout": "horizontal",
                            "source": "",
                            "children": [
                                {
                                    "type": "markdown",
                                    "source": "> <note/> *Lazy evaluation* is when the evaluation of certain expressions are deferred to as long as possible.",
                                    "uuid": "60f75a91-2164-4553-a189-ac7bc5b639ca",
                                    "version": 0
                                }
                            ],
                            "uuid": "914ad938-1723-4504-b461-95f050e01982",
                            "version": 0
                        },
                        {
                            "type": "box",
                            "layout": "horizontal",
                            "source": "Boolean conditions are evaluated lazily.",
                            "children": [
                                {
                                    "type": "markdown",
                                    "source": "C/C++/Java\n~~~\nbool x1 = false && deleteFile()\nbool x2 = true && deleteFile()\n~~~",
                                    "uuid": "bbe7b7fe-7cf2-43bf-a792-7b11d43431d1",
                                    "version": 0
                                },
                                {
                                    "type": "markdown",
                                    "source": "- The boolean variable `x1` is false, and `deleteFile()` is _never_ executed.\n- During the evaluation of `x2`, `deleteFile()` will be executed.",
                                    "uuid": "ba85d7e0-7b51-4bcc-b208-b049c072fed1",
                                    "version": 0
                                }
                            ],
                            "uuid": "1af3a40e-a2d9-4b47-ae46-17f8dfd3055f",
                            "version": 0
                        },
                        {
                            "type": "box",
                            "layout": "horizontal",
                            "source": "Other arithmetics are not lazy.",
                            "children": [
                                {
                                    "type": "markdown",
                                    "source": "C/C++/Java\n\n`int y = 0 * deleteFile()`",
                                    "uuid": "8abd1456-77b0-4903-a9c6-4b23127211f0",
                                    "version": 0
                                },
                                {
                                    "type": "markdown",
                                    "source": "The function `deleteFile()` will be executed in order to evaluate the value for `y`.",
                                    "uuid": "63275c87-13a2-4963-9178-20759b2cf388",
                                    "version": 0
                                }
                            ],
                            "uuid": "949374d2-0400-4e4b-95d4-5d7e47f05d91",
                            "version": 0
                        },
                        {
                            "type": "box",
                            "layout": "horizontal",
                            "source": "",
                            "children": [
                                {
                                    "type": "markdown",
                                    "source": "c: banner\n..................\nCompare expressions with and without side effects.",
                                    "uuid": "9562b093-4dfa-407f-97f1-dc390cd6c0c3",
                                    "version": 0
                                }
                            ],
                            "uuid": "2cd418ef-192b-4553-9040-412c3a806408",
                            "version": 0
                        },
                        {
                            "type": "box",
                            "layout": "horizontal",
                            "source": "",
                            "children": [
                                {
                                    "type": "markdown",
                                    "source": "- Lazy evaluation is crucial for control structures with expressions with side effects.\n\n  > For `if-then-else`, we can only evaluate *one* of the two expressions.\n  \n- Lazy evaluation is not necessary for expressions without side effects.\n\n  > For `if-then-else`, we can evaluate *both* true and false expressions, because they have no side effects.",
                                    "uuid": "fbf122d2-44eb-4ce9-8620-5971e2c08f36",
                                    "version": 0
                                }
                            ],
                            "uuid": "97afd6e0-5e40-4403-927f-96cc6e2693b3",
                            "version": 0
                        }
                    ],
                    "uuid": "f41615f9-581a-4e75-a067-2e681e20d02d",
                    "version": 0
                },
                {
                    "type": "section",
                    "source": "Lazy evaluation & Functional Programming",
                    "children": [
                        {
                            "type": "box",
                            "layout": "horizontal",
                            "source": "",
                            "children": [
                                {
                                    "type": "markdown",
                                    "source": "Assume that all expressions in a program are free of side effects.\n- The order of evaluation does not matter.\n- We want to minimize the number of expression evaluations for performance considerations.\n- We can set *all* expression evaluations to be lazy.\n  > Only evaluate an expression when it is needed.",
                                    "uuid": "2a9dcb00-72bc-4055-a84e-8ac562f369a6",
                                    "version": 0
                                },
                                {
                                    "type": "markdown",
                                    "source": "It can be confusing when an expression is evaluated.\n\nScala / Clojure:\n> Special syntax is used to declare that certain expressions are to be evaluated lazily.\n\nC / C++ / Java:\n> (Almost) everything is evaluated immediately.\n\nHaskell:\n> Everything is evaluated lazily.",
                                    "uuid": "f3048991-e0f5-4d64-88d3-535f34ac181a",
                                    "version": 0
                                }
                            ],
                            "uuid": "a074fe0c-1d30-49fd-ad95-5c9268f093b1",
                            "version": 0
                        }
                    ],
                    "uuid": "a80fa86c-e3cd-402c-a401-590a8b2786f7",
                    "version": 0
                }
            ],
            "uuid": "f174c0fe-2d99-4cc2-ba19-87e39b569514",
            "version": 0
        },
        {
            "type": "page",
            "source": "Higher Order Functions",
            "children": [
                {
                    "type": "section",
                    "source": "Definition",
                    "children": [
                        {
                            "type": "box",
                            "layout": "horizontal",
                            "source": "",
                            "children": [
                                {
                                    "type": "markdown",
                                    "source": "> <note/> A higher order function (HOF) is a function which\n> 1. accepts a function as its parameter, or\n> 2. returns a function as its output.\n\n",
                                    "uuid": "ea3b5115-7fc5-446d-b74c-55165aac449c",
                                    "version": 0
                                },
                                {
                                    "type": "markdown",
                                    "source": "We have already encountered HOFs, as they are used for currying a multi-argument function to a chain of single-argument functions. ",
                                    "uuid": "102b2656-fdaa-48ae-80cf-e94c29b2068e",
                                    "version": 0
                                }
                            ],
                            "uuid": "e9fbd5b0-d379-4f86-8115-937cc0037ebc",
                            "version": 0
                        }
                    ],
                    "uuid": "5b6c4bb2-6455-4f03-9e15-ee602684e453",
                    "version": 0
                },
                {
                    "type": "section",
                    "source": "................\nExample: map",
                    "children": [
                        {
                            "type": "box",
                            "layout": "horizontal",
                            "source": "",
                            "children": [
                                {
                                    "type": "markdown",
                                    "source": "Suppose we want to design a function that applies some operation to each element of a list.  This function is often called a _map_.\n\n~~~\nintMap: (List[Int], Int => Int) => List[Int]\n~~~\n\nHow do we implement this function?",
                                    "uuid": "8ca7c280-4102-40ca-880d-2955f5f6edbf",
                                    "version": 0
                                }
                            ],
                            "uuid": "199356fa-8f06-4f5f-84d1-e1bc5d18c2a7",
                            "version": 0
                        },
                        {
                            "type": "box",
                            "layout": "horizontal",
                            "source": "w: 1 2",
                            "children": [
                                {
                                    "type": "markdown",
                                    "source": "Just think that functions are values.  When we want to invoke a function that is bound to the symbol `f`, use `f(...)`.",
                                    "uuid": "17bd561e-66bf-42c6-9133-6d7154a9c095",
                                    "version": 0
                                },
                                {
                                    "type": "code",
                                    "source": "lang: scala\n..................\nimport scala.collection.mutable.MutableList\n\ndef intMap(list List[Int], f:Int=>Int):List[Int] = {\n  val result = MutableList[Int]()\n  for(x <- list) {\n    result += f(x)\n  }\n  result\n}",
                                    "uuid": "1439c3de-0a95-41ec-8c1a-cfc7ddcbf76c",
                                    "version": 0
                                }
                            ],
                            "uuid": "844ba04a-5662-41c6-bd77-b763e8481a28",
                            "version": 0
                        }
                    ],
                    "uuid": "6f7e9b9e-6459-4fbb-a8d7-54a8493447d9",
                    "version": 0
                },
                {
                    "type": "section",
                    "source": "Custom Control Structures",
                    "children": [
                        {
                            "type": "box",
                            "layout": "horizontal",
                            "source": "",
                            "children": [
                                {
                                    "type": "markdown",
                                    "source": "Let's explore ways of using HOF to implement control structures.\n\nWe will examine through some examples:\n\n- Control structures as HOF\n- Lazy evaluation of expressions with side effects",
                                    "uuid": "f5ab2418-1235-481f-8695-ab1ea8571a56",
                                    "version": 0
                                }
                            ],
                            "uuid": "96ab8f89-97d8-4a3a-bc8e-5cf364718594",
                            "version": 0
                        },
                        {
                            "type": "box",
                            "layout": "horizontal",
                            "source": "w: 1 3",
                            "children": [
                                {
                                    "type": "markdown",
                                    "source": "Run an expression `e`,  `n` times.",
                                    "uuid": "e3a116fb-8aa2-49ba-9076-de0900fbb659",
                                    "version": 0
                                },
                                {
                                    "type": "code",
                                    "source": "lang: scala\n.......................\nval Repeat: Int => (() => Any) => Unit = {\n  n => {\n    f => {\n      for(_ <- 0 until n) f.apply\n    }\n  }\n}",
                                    "uuid": "78bd6a1d-ed03-48c8-9b69-c68f82bcd67c",
                                    "version": 0
                                }
                            ],
                            "uuid": "dd61c3c1-051f-49d8-a9f5-6333085d6658",
                            "version": 0
                        },
                        {
                            "type": "box",
                            "layout": "horizontal",
                            "source": "w: 1 3",
                            "children": [
                                {
                                    "type": "markdown",
                                    "source": "",
                                    "uuid": "6d6dd127-b8b0-422c-99da-e647df5d83b7",
                                    "version": 0
                                },
                                {
                                    "type": "code",
                                    "source": "lang: scala\n.......................\nval runMe = () => {\n  println(\"Hello\")\n  println(\"\\t\\tworld.\")\n}\nRepeat(3)(runMe)",
                                    "uuid": "707435f7-ac4a-4a5a-b5ca-bcf9f655eb4a",
                                    "version": 0
                                }
                            ],
                            "uuid": "b4a5d58f-2b92-4678-b8a5-95224ef10cf0",
                            "version": 0
                        },
                        {
                            "type": "box",
                            "layout": "horizontal",
                            "source": "",
                            "children": [
                                {
                                    "type": "markdown",
                                    "source": "*The importance of lazy evaluation*\n***\n\nLet's consider another control structure:\n\n> We will invent a new control structure called `unless`. It takes an expression to as a condition, and a statement.  The statement is evaluated **only** if the condition is false.\n>\n> Here is sample usage\n>  ~~~\nunless(age > 65, () => println(\"You are not a senior.\"))\n  ~~~\n  \n",
                                    "uuid": "792a04fa-b42c-488f-bae8-5c9e9529ef03",
                                    "version": 0
                                }
                            ],
                            "uuid": "5969955f-77c5-427e-99c1-4b7904b77a62",
                            "version": 0
                        },
                        {
                            "type": "box",
                            "layout": "vertical",
                            "source": "w: 2 3",
                            "children": [
                                {
                                    "type": "markdown",
                                    "source": "Let's examine the type signature of `unless`.\n\n> `unless: (Boolean, () => Unit): Unit`\n\nHere is the implementation.",
                                    "uuid": "51c2398c-4c05-4d72-899f-2197fceb701a",
                                    "version": 0
                                },
                                {
                                    "type": "code",
                                    "source": "lang: scala\n.....................\ndef unless(cond: Boolean, f:() => Unit) = {\n  if(! cond) {\n    f()\n  }\n}",
                                    "uuid": "73f11199-b907-42ba-81a1-47befc171fbe",
                                    "version": 6
                                }
                            ],
                            "uuid": "57460272-1bf8-4510-99d9-efdb0655b063",
                            "version": 6
                        },
                        {
                            "type": "box",
                            "layout": "horizontal",
                            "source": "w: 2 1",
                            "children": [
                                {
                                    "type": "markdown",
                                    "source": "Let's improve the syntax.\n\nWe would like to have:\n\n~~~\nunless(age > 65, { println(\"You are not a senior.\" })\n~~~\n\n",
                                    "uuid": "3d1d8c51-3d3e-4bd7-bb2f-dde1a3b1208f",
                                    "version": 0
                                },
                                {
                                    "type": "markdown",
                                    "source": "css:\n  color: blue\n............\nWe need to reconsider the type signature of `unless`.\n\nScala supports lazily evaluated expressions for function arguments.",
                                    "uuid": "131f70ba-9106-43f5-a6b8-5a648e2ece26",
                                    "version": 129
                                }
                            ],
                            "uuid": "549e601d-52fb-4372-a3bc-e9402b95e06f",
                            "version": 130
                        },
                        {
                            "type": "box",
                            "layout": "vertical",
                            "source": "",
                            "children": [
                                {
                                    "type": "markdown",
                                    "source": "Let's first redefine `unless` with the new type signature:\n\n> `unless: (cond: Boolean, code: => Unit)`\n\n",
                                    "uuid": "99591332-88dd-4856-9176-e8c4c3344b0e",
                                    "version": 155
                                },
                                {
                                    "type": "box",
                                    "layout": "horizontal",
                                    "source": "w: 3 1",
                                    "children": [
                                        {
                                            "type": "code",
                                            "source": "lang: scala\n...............\ndef unless(cond:Boolean, code: => Unit) = {\n  if(! cond) code\n}",
                                            "uuid": "d23d8d8e-bb58-4f20-b13f-32ac7506fc23",
                                            "version": 142
                                        },
                                        {
                                            "type": "markdown",
                                            "source": "css:\n  color: blue\n............\nThe `code: => Unit` is a lazily evaluated expression (which evaluates to `Unit`).  It only gets evaluated when its _name_ is referred to.\n\nThis is called *by-name* parameters.",
                                            "uuid": "5055ba2c-66fa-4d7d-8bae-5f049a66c6f8",
                                            "version": 245
                                        }
                                    ],
                                    "uuid": "aca1bde0-c314-4be2-9da4-6cb20eac9309",
                                    "version": 257
                                }
                            ],
                            "uuid": "cb19810c-9aa3-4bdb-958c-9d3029699e81",
                            "version": 557
                        },
                        {
                            "type": "box",
                            "layout": "horizontal",
                            "source": "w: 1 3",
                            "children": [
                                {
                                    "type": "markdown",
                                    "source": "\nLet's use the new `unless`:",
                                    "uuid": "9e7cf270-9704-404a-9f5f-a147833178f2",
                                    "version": 45
                                },
                                {
                                    "type": "code",
                                    "source": "lang: scala\n...............................\nunless(age > 65, println(\"You are not a senior\"))",
                                    "uuid": "7666862c-b4ad-4f77-a547-b57bc7c166b8",
                                    "version": 103
                                }
                            ],
                            "uuid": "8c9a0938-1383-4564-82b2-05c623f6c730",
                            "version": 162
                        },
                        {
                            "type": "box",
                            "layout": "horizontal",
                            "source": "",
                            "children": [
                                {
                                    "type": "markdown",
                                    "source": "css:\n  fontSize: 150%\n......................\n- Why is lazily evaluation necessary for the `code` parameter?\n- Is it still necessary if the expression has *no* side-effects?",
                                    "uuid": "eb9b0af8-15bf-4356-88eb-559d148a861e",
                                    "version": 219
                                }
                            ],
                            "uuid": "c5c3b77d-a481-455d-aeb6-0be383047560",
                            "version": 219
                        }
                    ],
                    "uuid": "21b2205c-1a2b-4eff-88ad-658af6b0a152",
                    "version": 1076
                },
                {
                    "type": "section",
                    "source": "A preview of Scala's scalable syntax",
                    "children": [
                        {
                            "type": "box",
                            "layout": "horizontal",
                            "source": "",
                            "children": [
                                {
                                    "type": "markdown",
                                    "source": "Scala stands for _a scalable language_.  We will show how it's syntax resolution rules allow one to extend the scala syntax using HOF.",
                                    "uuid": "62c07f44-4f0c-43bb-8f6b-ceb02228d4b0",
                                    "version": 178
                                }
                            ],
                            "uuid": "af988805-e609-46ec-a4b1-a9a29ee75f17",
                            "version": 179
                        },
                        {
                            "type": "box",
                            "layout": "horizontal",
                            "source": "w: 0 1",
                            "children": [
                                {
                                    "type": "code",
                                    "source": "class UnlessStatement(cond: Boolean) {\n    def Do(code: => Unit) = {\n        if(! cond) code\n    }\n}\n\nobject Check {\n    def Unless(cond: Boolean):UnlessStatement = {\n        return new UnlessStatement(cond)\n    }\n}\n",
                                    "uuid": "097972eb-4c49-4c9a-90b8-f1065a9d1dd9",
                                    "version": 157
                                },
                                {
                                    "type": "markdown",
                                    "source": "We can use `Check` as a totally new control structure:\n\n~~~\nCheck Unless (age > 65) Do {\n  println(\"not a senior\")\n}\n~~~",
                                    "uuid": "014a71d4-7846-49f4-b22e-9590afafa15d",
                                    "version": 160
                                }
                            ],
                            "uuid": "987a7ef7-875d-4a00-8448-8af15114e3b8",
                            "version": 357
                        }
                    ],
                    "uuid": "f93d64a5-51b4-45f0-8adc-45fe4b0a5353",
                    "version": 658
                }
            ],
            "uuid": "61fcffec-8070-431b-9a4d-2e8e7eb11a4b",
            "version": 1735
        }
    ],
    "uuid": "9d323ccc-8b57-4642-8a49-a6dde38acb61",
    "modified": false,
    "version": 1735,
    "history": 6
}